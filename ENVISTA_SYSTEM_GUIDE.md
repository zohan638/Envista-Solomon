# Envista Opta Motion Controller — System + Modbus Interface Guide

This document describes how to operate the Envista motion controller (Arduino Opta Lite PLC + expansions) and how to build your own Modbus-TCP master application to control it.

## 1) System overview

### Hardware

- **Controller:** Arduino Opta Lite PLC (IEC 61131-3 Structured Text + Arduino sketch for Ethernet/Modbus TCP).
- **Axes:**
  - **Linear actuator** driven by a stepper motor via **DM542T**.
  - **Turntable** driven by a stepper motor via **DM542T** and a **180:1 worm gear**.
- **Sensors / Interlocks:**
  - Actuator **left** and **right** limit switches (read as analog/ADC-style inputs).
  - **Door sensor** (ADC-style input). Door open stops motion.
- **Outputs:**
  - STEP pulses are generated by PLC PWM outputs.
  - DIR and ENA are routed through Opta relay outputs (introduces switching + bounce delays).

### Software architecture

- The PLC is a **Modbus TCP slave**.
- A PC-side application is the **Modbus TCP master** (your debug UI now, and later your production application).
- Control is implemented as state machines on the PLC:
  - System-level state: READY/RUNNING/HALTED/FAULT
  - Actuator axis state machine: UNCAL/IDLE/CAL_SEEK/CAL_COUNT/MOVE/JOG/FAULT
  - Turntable axis state machine: IDLE/MOVE/JOG/FAULT + special home-reset mode

### Key design behaviors

- **Open-loop step counting:** position is estimated from commanded step frequency. If the motor stalls or skips steps, the estimated position will drift.
- **Enable gating:** with the final firmware, the **SYS_CMD_ALLOW_MOTION** bit is the master “power/enable” gate. When it is **ON**, both drives are enabled (except in door interlock or TT reset-home mode). When it is **OFF**, both drives are disabled.
- **Relay-driven DIR/ENA:** because DIR and ENA are switched via relays, the PLC enforces a safety delay before emitting STEP pulses after:
  1) enabling a drive, or
  2) changing direction.
  
  The DM542T timing requirements include minimum pulse width and direction setup time, and a recommended enable lead time.

  Opta relay switching and bounce times should also be considered.

## 2) Safety & interlocks

### Door interlock (ADC-style)

- Input: `diDoorClosed` (UINT). Treated as ADC-like:
  - **Door closed:** `< 1000` (often ~19)
  - **Door open:** `> 2000` (often ~65535)
- Behavior:
  - If the door **opens while either axis is moving**, the PLC stops motion and **latches** the door fault until the user sends **SYS_CMD_RESET_FAULT**.
  - If the door opens while the system is idle, the interlock **auto-clears** when the door closes.
  - Door interlock disables drive ENA outputs (and inhibits STEP).

### Driver alarm

- Inputs: `diDrvActAlarm`, `diDrvTtAlarm`.
- If either alarm becomes active, the system enters fault state.

### Watchdog (master heartbeat)

- The master must periodically update `svSysMasterHeartbeat`.
- If the heartbeat does not change for longer than `pMasterWatchdogMs`, the PLC faults and stops.

## 3) Motion model & scaling

### Actuator

- After calibration:
  - Left limit = **0 steps**
  - Right limit = **maxSteps** (measured during calibration)
- All actuator targets are **absolute step positions** in `[0 .. maxSteps]`.

### Turntable

- Stepper is configured to **1600 steps/rev**.
- Worm gear: **180 motor revs = 1 turntable rev**.
- Therefore:
  - Steps per bed revolution = `1600 * 180 = 288,000`
  - Steps per bed degree = `288,000 / 360 = 800 steps/deg`

PLC commands use **degrees × 1000** (`deg_x1000`) and convert internally.

### Cyclic angle domain

- The PLC publishes the turntable position `svTtPosDeg_x1000` wrapped into:

> **(-180, 180] degrees**  (i.e., `(-180000, 180000]` in x1000 units)

Examples:

- `181.000° → -179.000°`
- `-181.000° → 179.000°`

This is a reporting convention; your application can still track an “absolute” multi-turn angle if you want.

## 4) PLC parameters (non-volatile)

Parameters are stored in a Modbus holding register block (see Modbus map below) and persist across reboots.

The most commonly used parameters for tuning are:

- `pMasterWatchdogMs` — master heartbeat timeout.
- Actuator tuning:
  - `pActCalibStepFreq`, `pActCalibAccel` — calibration speed and accel.
  - `pActMaxStepFreq`, `pActAccel`, `pActDecel`, `pActStopDecel` — motion profile.
- Turntable tuning:
  - `pTtMaxStepFreq`, `pTtAccel`, `pTtDecel`, `pTtStopDecel`.
- Timing:
  - `pDirSetupDelayMs` — extra delay to allow relay contacts + wiring to settle before stepping.
  - `pPwmMinPeriodUs` — caps maximum step frequency.
  - `pStepDutyPermil` — duty cycle of STEP (typ 500 = 50%).

### Calibration note (why step count can “grow”)

If you increase `pActCalibStepFreq` too aggressively, the motor can stall or skip steps. The PLC will still “count” commanded steps until the limit input changes, so the measured travel (maxSteps) can increase even though the physical travel is unchanged. In other words: **growing maxSteps is usually evidence of missed steps**. Calibrate at a conservative speed.

## 5) Modbus TCP interface

### Network

- Transport: **Modbus TCP** over Ethernet.
- Default port: **502**
- Unit ID: typically **255** (as used in your debug UI)

### Addressing (important)

The Opta PLC IDE presents Modbus holding registers using “PLC-style” addresses (e.g., 0x4000 / 0x6000).

Many Modbus client libraries (including pymodbus) use **0-based addressing**, so the debug UI uses:

- Parameter base = `0x4000 - 1 = 16383`
- Status base    = `0x6000 - 1 = 24575`

If you use a different Modbus master tool that expects 1-based addressing, you may need to adjust accordingly.

### Data types

- Most values are **UINT16** holding registers.
- 32-bit signed values are stored as **DINT** occupying **two** 16-bit registers.
- **Endianness:** this system uses **little-endian DINT** (low word first).

### Command handshake (robust pattern)

Each command block uses a `CmdWord` + `CmdSeq` + `AckSeq`:

1) Master writes any required data registers (e.g., actuator target DINT).
2) Master writes the appropriate `CmdWord` bits.
3) Master increments `CmdSeq` by 1 (commit).
4) PLC copies the received seq into `AckSeq` when it has processed the command.

This provides edge-triggered commands without relying on timing.

### Status + Parameter register maps

Below is the register map used by the final PLC firmware and debug UI.

#### 5.1 Status variables block (`SV`, volatile)

Block length: **33 registers**.

Base (PLC IDE): **0x6000** (dec 24576)
Base (pymodbus-style): **24575**

| Offset | Name | Type | R/W | Notes |
|---:|---|---|---|---|
| 0 | `svSysCmdWord` | UINT | RW | System command bits |
| 1 | `svSysCmdSeq` | UINT | RW | System commit counter |
| 2 | `svSysAckSeq` | UINT | RO | PLC copies last processed seq |
| 3 | `svSysStatusWord` | UINT | RO | Ready/Running/Fault/Door/Watchdog… |
| 4 | `svSysState` | UINT | RO | System state enum |
| 5 | `svSysFaultCode` | UINT | RO | Fault reason (system) |
| 6 | `svSysPlcHeartbeat` | UINT | RO | PLC increments periodically |
| 7 | `svSysMasterHeartbeat` | UINT | RW | Master increments periodically |
| 8 | `svActCmdWord` | UINT | RW | Actuator command bits |
| 9 | `svActCmdSeq` | UINT | RW | Actuator commit counter |
| 10 | `svActAckSeq` | UINT | RO | PLC ack |
| 11..12 | `svActTargetSteps` | DINT | RW | Absolute target in steps |
| 13..14 | `svActPosSteps` | DINT | RO | Estimated position steps |
| 15 | `svActStatusWord` | UINT | RO | Motion/cal/fault/limit flags |
| 16 | `svActState` | UINT | RO | Actuator state enum |
| 17 | `svActFaultCode` | UINT | RO | Actuator fault enum |
| 18 | `svActInMotion` | BOOL(WORD) | RO | 0/1 |
| 19 | `svActCalibValid` | BOOL(WORD) | RO | 0/1 |
| 20..21 | `svActCalibTotalSteps` | DINT | RO | maxSteps from calibration |
| 22 | `svActCalibSignature` | UINT | RO | magic for retained data |
| 23 | `svTtCmdWord` | UINT | RW | Turntable command bits |
| 24 | `svTtCmdSeq` | UINT | RW | Turntable commit counter |
| 25 | `svTtAckSeq` | UINT | RO | PLC ack |
| 26..27 | `svTtTargetDeg_x1000` | DINT | RW | Relative move (deg×1000) |
| 28..29 | `svTtPosDeg_x1000` | DINT | RO | Position (deg×1000), wrapped |
| 30 | `svTtStatusWord` | UINT | RO | Motion/fault/home-reset flags |
| 31 | `svTtState` | UINT | RO | Turntable state enum |
| 32 | `svTtFaultCode` | UINT | RO | Turntable fault enum |

#### 5.2 Parameter block (`PAR`, non-volatile)

Block length: **23 registers**.

Base (PLC IDE): **0x4000** (dec 16384)
Base (pymodbus-style): **16383**

| Offset | Name | Type | Notes |
|---:|---|---|---|
| 0 | `pUiIdleTimeoutMs` | UINT | UI LED timeout |
| 1 | `pUiLongPressMs` | UINT | UI long press threshold |
| 2 | `pDoorFaultIsLatch` | BOOL(WORD) | Door fault latch behavior (if used) |
| 3 | `pMasterWatchdogMs` | UINT | Watchdog timeout |
| 4 | `pCmdDebounceMs` | UINT | Debounce |
| 5..6 | `pActRangeMm_x1000` | DINT | Informational range |
| 7 | `pActCalibStepFreq` | UINT | steps/s |
| 8 | `pActCalibAccel` | UINT | steps/s² |
| 9 | `pActMaxStepFreq` | UINT | steps/s |
| 10 | `pActAccel` | UINT | steps/s² |
| 11 | `pActDecel` | UINT | steps/s² |
| 12 | `pActStopDecel` | UINT | steps/s² |
| 13 | `pActDirPolarity` | BOOL(WORD) | Act DIR polarity (typically fixed) |
| 14 | `pTtMaxStepFreq` | UINT | steps/s |
| 15 | `pTtAccel` | UINT | steps/s² |
| 16 | `pTtDecel` | UINT | steps/s² |
| 17 | `pTtStopDecel` | UINT | steps/s² |
| 18 | `pTtDirPolarity` | BOOL(WORD) | Turntable DIR polarity |
| 19 | `pStepDutyPermil` | UINT | e.g., 500 = 50% |
| 20 | `pDirSetupDelayMs` | UINT | relay/dir setup delay |
| 21 | `pPwmMinPeriodUs` | UINT | caps max step frequency |
| 22 | `pPwmOffPeriodUs` | UINT | 0 disables PWM output |

## 6) Command bit definitions

### 6.1 System (`svSysCmdWord`)

- `0x0001` — RESET_FAULT
- `0x0002` — HALT_ALL
- `0x0004` — CLEAR_HALT
- `0x0010` — ALLOW_MOTION (drive enables)
- `0x0020` — DEBUG_ENABLE (enables jog buttons)

### 6.2 Actuator (`svActCmdWord`)

- `0x0001` — CALIBRATE
- `0x0002` — GOTO_ABS (uses `svActTargetSteps`)
- `0x0004` — HALT
- `0x0010` — JOG_POS (debug)
- `0x0020` — JOG_NEG (debug)

### 6.3 Turntable (`svTtCmdWord`)

- `0x0001` — MOVE_REL (uses `svTtTargetDeg_x1000`)
- `0x0002` — HALT
- `0x0004` — JOG_CW (debug)
- `0x0008` — JOG_CCW (debug)
- `0x0010` — SET_HOME
- `0x0020` — RESET_HOME

## 7) Turntable home workflow

Goal: choose a physical “home” position and make it be 0°.

1) Ensure system is safe and **axes are stopped**.
2) Open door (if your procedure requires), or otherwise ensure the TT can be moved safely.
3) Send **TT RESET_HOME**.
   - PLC disables turntable drive (ENA off) so the table can be rotated by hand.
4) Manually rotate the bed to the desired “home” orientation.
5) Send **TT SET_HOME**.
   - PLC records the current step position as the home offset.
   - PLC resumes normal turntable control.

## 8) Building your own master application

### Minimal responsibilities

Your master app must:

1) Maintain `svSysMasterHeartbeat` (e.g., update every 100–250 ms).
2) Use the `CmdSeq/AckSeq` handshake when issuing commands.
3) Keep `SYS_CMD_ALLOW_MOTION` ON only when safe to energize the drives.
4) Handle door interlock behavior:
   - If door opens while moving, you must issue `RESET_FAULT` after closing the door.

### Recommended control loop

- Poll the status block at ~5–10 Hz for UI and state logic.
- Faster polling is fine, but don’t overload the PLC.

### Python helper module

Along with this guide you requested a reusable Python module (`envista_modbus_client.py`) that:

- Implements the register map/constants.
- Packs/unpacks DINT (little-endian).
- Provides safe helper methods for:
  - allow motion / reset fault / halt
  - actuator calibrate/goto/halt
  - turntable move/jog/halt
  - turntable set/reset home
- Provides a built-in heartbeat thread.

See the module docstring + examples in that file.

## Appendix B — Status words, states, and fault codes

### B.1 `svSysStatusWord` bitfield

| Bit | Mask | Meaning |
|---:|---:|---|
| 0 | 0x0001 | READY (system is idle + able to accept commands) |
| 1 | 0x0002 | RUNNING (any axis in motion) |
| 2 | 0x0004 | FAULT (system fault or door interlock active) |
| 3 | 0x0008 | HALTED (HALT_ALL latched) |
| 4 | 0x0010 | WATCHDOG OK |
| 5 | 0x0020 | DEBUG ENABLE |
| 6 | 0x0040 | ALLOW_MOTION (drive enables requested) |
| 7 | 0x0080 | DOOR OPEN |
| 8 | 0x0100 | DOOR LATCHED (door opened while moving; requires reset) |

### B.2 System states (`svSysState`)

| Value | Meaning |
|---:|---|
| 10 | IDLE_NO_CAL (actuator not calibrated yet) |
| 20 | READY |
| 30 | RUNNING |
| 40 | HALTED |
| 80 | FAULT |

### B.3 Actuator states (`svActState`)

| Value | Meaning |
|---:|---|
| 10 | UNCAL (not calibrated) |
| 20 | IDLE |
| 30 | CAL_SEEK_LEFT |
| 40 | CAL_SEEK_RIGHT_COUNT |
| 60 | MOVE |
| 70 | JOG (debug) |
| 90 | FAULT |

### B.4 Turntable states (`svTtState`)

| Value | Meaning |
|---:|---|
| 20 | IDLE |
| 60 | MOVE |
| 70 | JOG (debug) |
| 90 | FAULT |

### B.5 Fault codes

`svSysFaultCode` (system):

| Code | Meaning |
|---:|---|
| 0 | No fault |
| 10 | Watchdog stale |
| 11 | Drive alarm (either axis alarm input asserted) |
| 12 | Actuator limit fault / illegal endstop condition |
| 13 | Calibration timeout |
| 14 | Door interlock active |

`svActFaultCode` (actuator):

| Code | Meaning |
|---:|---|
| 0 | No fault |
| 1 | Drive alarm |
| 2 | Limit fault |
| 3 | Not calibrated |
| 4 | Timeout |

`svTtFaultCode` (turntable) is typically:

| Code | Meaning |
|---:|---|
| 0 | No fault |
| 1 | Drive alarm |

## Appendix C — Modbus examples (raw)

### C.1 Actuator goto (absolute steps)

1. Write the DINT `svActTargetSteps` (two registers, low word first).
2. Write `svActCmdWord = 0x0002` (GOTO_ABS).
3. Increment `svActCmdSeq`.
4. Poll until `svActAckSeq == svActCmdSeq` and `svActInMotion` goes 1→0.

### C.2 Turntable move relative (degrees)

1. Convert degrees to `deg_x1000`.
2. Write `svTtTargetDeg_x1000` (DINT).
3. Write `svTtCmdWord = 0x0001` (MOVE_REL).
4. Increment `svTtCmdSeq`.

## Appendix D — Modbus examples (using the helper module)

```python
from envista_modbus_client import EnvistaClient

with EnvistaClient("169.254.129.10") as plc:
    plc.start_heartbeat()

    # Enable drives
    plc.set_allow_motion(True)

    # Calibrate actuator
    plc.actuator_calibrate(wait=True, timeout_s=180)

    # Go to mid position
    st = plc.read_status()
    mid = st.act_calib_total_steps // 2
    plc.actuator_goto(mid, wait=True)

    # Turntable: rotate +30° (relative)
    plc.turntable_move_rel(30.0, wait=False)

    # Home workflow
    plc.turntable_reset_home()
    input("Rotate bed by hand, then press Enter...")
    plc.turntable_set_home()
```


---

## Appendix A — Timing notes (DM542T + relay)

The DM542T manual specifies minimum pulse width and direction setup time (µs-level), and also indicates enable timing rules (including a recommended lead-in).

Because Opta relay outputs have finite closing/opening times and contact bounce, the PLC logic intentionally delays step pulses after relay transitions.

## References

- Arduino Opta / expansion datasheet(s) (relay timing, IO characteristics)
- DM542T driver datasheet (ENA/DIR/PUL timing)
- Arduino PLC IDE documentation (variables, ST execution model)
